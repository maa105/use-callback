{"version":3,"sources":["../../src/useBindedCallback.ts","App.tsx","../../src/useFixedCallback.ts","../../src/useDynamicBindedCallback.ts","../../src/useFixedCallbackMapper.ts","../../src/useBindedCallbackMapper.ts","../../src/useDynamicBindedCallbackMapper.ts","index.tsx"],"names":["useBindedCallback","handler","ref","useRef","current","bindArgs","mutable","callback","args","Child","React","memo","onClick","label","renderCountRef","UseFixedCallbackTest","useState","counter","setCounter","useFixedCallback","e","stopPropagation","UseBindedCallbackTest","counterSetter","UseBindedCallbackTest2","UseDynamicBindedCallbackTest","useDynamicBindedCallback","setHandler","UseFixedCallbackMapperTest","id","items","setItems","mapper","itemsMutable","getKey","keyGetter","obj","maxKeyCount","mapped","array","key","itemMutable","mapFunction","currentItemMutable","count","item","deletedKeys","useFixedCallbackMapper","map","itm","split","parseFloat","length","filter","useBindedCallbackMapperHandler","UseBindedCallbackMapperTest","useBindedCallbackMapper","UseDynamicBindedCallbackMapperTest","useDynamicBindedCallbackMapper","setKeyGetter","App","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.ccc4a36e.chunk.js","sourcesContent":["import { useRef } from 'react'\nimport { Handler, UseBindedCallbackState } from './typings'\n\nconst useBindedCallback = (handler: Handler, ...bindArgs: any[]) => {\n  const ref = useRef<UseBindedCallbackState>()\n  const current = ref.current\n  if (current) {\n    current.handler = handler\n    current.bindArgs = bindArgs\n    return current.callback\n  }\n  const mutable: any = {\n    handler,\n    bindArgs\n  }\n  const callback = function (this: any, ...args: any[]) {\n    return mutable.handler.call(this, ...mutable.bindArgs, ...args)\n  }\n  mutable.callback = callback\n  ref.current = mutable\n  return callback\n}\n\nexport default useBindedCallback\n","import React, { useRef, useState } from 'react'\n\nimport {\n  useFixedCallback,\n  useBindedCallback,\n  useDynamicBindedCallback,\n  useFixedCallbackMapper,\n  useBindedCallbackMapper,\n  useDynamicBindedCallbackMapper\n} from 'use-callback-maa'\n\ntype ChildProps = {\n  label: string\n  onClick: React.MouseEventHandler\n}\ntype Item = {\n  id: string\n  label: string\n}\ntype Items = Array<Item>\n\nconst Child = React.memo(({ onClick, label }: ChildProps) => {\n  const renderCountRef = useRef(0)\n  ++renderCountRef.current\n  return (\n    <button onClick={onClick}>\n      {label}\n      <br />\n      RenderCount:{renderCountRef.current}\n    </button>\n  )\n})\n\nconst UseFixedCallbackTest = () => {\n  const [counter, setCounter] = useState(0)\n  const onClick = useFixedCallback((e: React.MouseEvent) => {\n    e.stopPropagation()\n    setCounter(counter + 1)\n  })\n  return (\n    <div>\n      <div>Counter: {counter}</div>\n      <Child onClick={onClick} label='Click Me' />\n    </div>\n  )\n}\n\nconst UseBindedCallbackTest = () => {\n  const [counter, setCounter] = useState(0)\n  const onClick = useBindedCallback(\n    (\n      setCounter: React.Dispatch<React.SetStateAction<number>>,\n      counter: number,\n      e: React.MouseEvent\n    ) => {\n      e.stopPropagation()\n      setCounter(counter + 1)\n    },\n    setCounter,\n    counter\n  )\n  // OR like below. This way the handler will not be recreated on each render\n  // const onClick = useBindedCallback(counterSetter, setCounter, counter)\n  return (\n    <div>\n      <div>Counter: {counter}</div>\n      <Child onClick={onClick} label='Click Me' />\n    </div>\n  )\n}\n\nconst counterSetter = (\n  setCounter: React.Dispatch<React.SetStateAction<number>>,\n  counter: number\n) => setCounter(counter + 1)\nconst UseBindedCallbackTest2 = () => {\n  const [counter, setCounter] = useState(0)\n  const onClick = useBindedCallback(counterSetter, setCounter, counter)\n  return (\n    <div>\n      <div>Counter: {counter}</div>\n      <Child onClick={onClick} label='Click Me' />\n    </div>\n  )\n}\n\nconst UseDynamicBindedCallbackTest = () => {\n  const [counter, setCounter] = useState(0)\n  const onClick = useDynamicBindedCallback(setCounter, counter)\n  onClick.setHandler?.(\n    (\n      setCounter: React.Dispatch<React.SetStateAction<number>>,\n      counter: number,\n      e: React.MouseEvent\n    ) => {\n      e.stopPropagation()\n      setCounter(counter + 1)\n    }\n  )\n\n  return (\n    <div>\n      <div>\n        Counter: {counter}\n        {onClick.setHandler ? 'WITH setHandler???' : ''}\n      </div>\n      <Child onClick={onClick} label='Click Me' />\n    </div>\n  )\n}\n\nconst UseFixedCallbackMapperTest = () => {\n  const [counter, setCounter] = useState(0)\n  const [items, setItems] = useState(() => [\n    { id: '1', label: 'Item 1' },\n    { id: '2', label: 'Item 2' },\n    { id: '3', label: 'Item 3' }\n  ])\n\n  const mapper = useFixedCallbackMapper((item: Item, e: React.MouseEvent) => {\n    e.stopPropagation()\n    setCounter(counter + 1)\n    if (counter % 6 === 1) {\n      setItems(\n        items.map((itm: Item) => {\n          return itm.id === item.id\n            ? {\n                ...itm,\n                label: `${itm.label.split('[')[0]}[Updated@${counter + 1}]`\n              }\n            : itm\n        })\n      )\n    }\n    if (counter % 6 === 3) {\n      setItems([\n        ...items,\n        {\n          id: `${parseFloat(items[items.length - 1].id) + 1}`,\n          label: `Item ${parseFloat(items[items.length - 1].id) + 1}[NEW]`\n        }\n      ])\n    }\n    if (counter % 6 === 5) {\n      setItems(items.filter(({ id }: Item) => id !== item.id))\n    }\n  }, 'id')\n\n  return (\n    <div>\n      <b>Every second click will do something.</b>{' '}\n      <i>\n        Cycled actions: update clicked -&gt; create new -&gt; delete clicked\n      </i>\n      <div>Counter: {counter}</div>\n      {mapper(\n        items,\n        (\n          key: string,\n          callback: React.MouseEventHandler,\n          item: Item\n          // i: number,\n          // items: Items\n        ) => (\n          <Child key={key} onClick={callback} label={item.label} />\n        )\n      )}\n    </div>\n  )\n}\n\nconst useBindedCallbackMapperHandler = (\n  item: Item,\n  counter: number,\n  setCounter: React.Dispatch<React.SetStateAction<number>>,\n  items: Items,\n  setItems: React.Dispatch<React.SetStateAction<Items>>,\n  e: React.MouseEvent\n) => {\n  e.stopPropagation()\n  setCounter(counter + 1)\n  if (counter % 6 === 1) {\n    setItems(\n      items.map((itm: Item) => {\n        return itm.id === item.id\n          ? {\n              ...itm,\n              label: `${itm.label.split('[')[0]}[Updated@${counter + 1}]`\n            }\n          : itm\n      })\n    )\n  }\n  if (counter % 6 === 3) {\n    setItems([\n      ...items,\n      {\n        id: `${parseFloat(items[items.length - 1].id) + 1}`,\n        label: `Item ${parseFloat(items[items.length - 1].id) + 1}[NEW]`\n      }\n    ])\n  }\n  if (counter % 6 === 5) {\n    setItems(items.filter(({ id }: Item) => id !== item.id))\n  }\n}\nconst UseBindedCallbackMapperTest = () => {\n  const [counter, setCounter] = useState(0)\n  const [items, setItems] = useState(() => [\n    { id: '1', label: 'Item 1' },\n    { id: '2', label: 'Item 2' },\n    { id: '3', label: 'Item 3' }\n  ])\n\n  const mapper = useBindedCallbackMapper(\n    useBindedCallbackMapperHandler,\n    'id',\n    counter,\n    setCounter,\n    items,\n    setItems\n  )\n\n  return (\n    <div>\n      <b>Every second click will do something.</b>{' '}\n      <i>\n        Cycled actions: update clicked -&gt; create new -&gt; delete clicked\n      </i>\n      <div>Counter: {counter}</div>\n      {mapper(\n        items,\n        (\n          key: string,\n          callback: React.MouseEventHandler,\n          item: Item\n          // i: number,\n          // items: Items\n        ) => (\n          <Child key={key} onClick={callback} label={item.label} />\n        )\n      )}\n    </div>\n  )\n}\n\nconst UseDynamicBindedCallbackMapperTest = () => {\n  const [counter, setCounter] = useState(0)\n  const [items, setItems] = useState(() => [\n    { id: '1', label: 'Item 1' },\n    { id: '2', label: 'Item 2' },\n    { id: '3', label: 'Item 3' }\n  ])\n\n  const mapper = useDynamicBindedCallbackMapper(counter, items) // setCounter and setItems have fixed identities not need to bind them\n  mapper.setKeyGetter?.('id')\n  mapper.setHandler?.(\n    (item: Item, counter: number, items: Items, e: React.MouseEvent) => {\n      e.stopPropagation()\n      setCounter(counter + 1)\n      if (counter % 6 === 1) {\n        setItems(\n          items.map((itm: Item) => {\n            return itm.id === item.id\n              ? {\n                  ...itm,\n                  label: `${itm.label.split('[')[0]}[Updated@${counter + 1}]`\n                }\n              : itm\n          })\n        )\n      }\n      if (counter % 6 === 3) {\n        setItems([\n          ...items,\n          {\n            id: `${parseFloat(items[items.length - 1].id) + 1}`,\n            label: `Item ${parseFloat(items[items.length - 1].id) + 1}[NEW]`\n          }\n        ])\n      }\n      if (counter % 6 === 5) {\n        setItems(items.filter(({ id }: Item) => id !== item.id))\n      }\n    }\n  )\n\n  return (\n    <div>\n      <b>Every second click will do something.</b>{' '}\n      <i>\n        Cycled actions: update clicked -&gt; create new -&gt; delete clicked\n      </i>\n      <div>Counter: {counter}</div>\n      {mapper(\n        items,\n        (\n          key: string,\n          callback: React.MouseEventHandler,\n          item: Item\n          // i: number,\n          // items: Items\n        ) => (\n          <Child key={key} onClick={callback} label={item.label} />\n        )\n      )}\n    </div>\n  )\n}\n\nconst App = () => {\n  return (\n    <div>\n      <h2>Note</h2>\n      <div>\n        Render count should nerver change for the first 4. The last 3 render\n        count only change when label is updated (denoted by\n        [Updates@&lt;number&gt;]).{' '}\n        <i>Counter is incremented by 1 on each click</i>\n      </div>\n      <h2>Tests</h2>\n      <hr />\n      useFixedCallback:\n      <UseFixedCallbackTest />\n      <hr />\n      useBindedCallback:\n      <UseBindedCallbackTest />\n      <hr />\n      useBindedCallback (with global handler):\n      <UseBindedCallbackTest2 />\n      <hr />\n      useDynamicBindedCallback:\n      <UseDynamicBindedCallbackTest />\n      <hr />\n      useFixedCallbackMapper:\n      <UseFixedCallbackMapperTest />\n      <hr />\n      useBindedCallbackMapper:\n      <UseBindedCallbackMapperTest />\n      <hr />\n      useDynamicBindedCallbackMapper:\n      <UseDynamicBindedCallbackMapperTest />\n      <hr />\n    </div>\n  )\n}\n\nexport default App\n","import { useRef } from 'react'\nimport { Handler, UseFixedCallbackState } from './typings'\n\nconst useFixedCallback = (handler: Handler) => {\n  const ref = useRef<UseFixedCallbackState>()\n  const current = ref.current\n  if (current) {\n    current.handler = handler\n    return current.callback\n  }\n  const mutable: any = {\n    handler\n  }\n  const callback = function (this: any, ...args: any[]) {\n    return mutable.handler.apply(this, args)\n  }\n  mutable.callback = callback\n  ref.current = mutable\n  return callback\n}\n\nexport default useFixedCallback\n","import { useRef } from 'react'\nimport {\n  DynamicCallback,\n  Handler,\n  UseDynamicBindedCallbackState\n} from './typings'\n\nconst useDynamicBindedCallback = (...bindArgs: any[]) => {\n  const ref = useRef<UseDynamicBindedCallbackState>()\n  const current = ref.current\n  if (current) {\n    current.bindArgs = bindArgs\n    return current.callback\n  }\n  const mutable: any = { bindArgs }\n  const callback: DynamicCallback = function (this: any, ...args: any[]) {\n    return mutable.handler.call(this, ...mutable.bindArgs, ...args)\n  }\n  callback.setHandler = (handler: Handler) => {\n    mutable.handler = handler\n    delete callback.setHandler\n  }\n  mutable.callback = callback\n  ref.current = mutable\n  return callback\n}\n\nexport default useDynamicBindedCallback\n","import { useRef } from 'react'\nimport {\n  Handler,\n  KeyGetter,\n  MapFunction,\n  UseFixedCallbackMapperState,\n  UseCallbackMapperItemsState,\n  UseCallbackMapperItemState\n} from './typings'\n\nconst useFixedCallbackMapper = (\n  handler: Handler,\n  keyGetter: string | KeyGetter\n) => {\n  const ref = useRef<UseFixedCallbackMapperState>()\n  const current = ref.current\n  if (current) {\n    current.handler = handler\n    return current.mapper\n  }\n  const itemsMutable: UseCallbackMapperItemsState = {}\n  const getKey: KeyGetter =\n    typeof keyGetter === 'string' ? (obj: Object) => obj[keyGetter] : keyGetter\n  let maxKeyCount = 0\n  const mutable: UseFixedCallbackMapperState = {\n    handler,\n    mapper: (array: Array<Object>, mapFunction: MapFunction) => {\n      ++maxKeyCount\n      const mapped = array.map((item, index, array) => {\n        const key = getKey(item)\n        const itemMutable = itemsMutable[key]\n        if (itemMutable) {\n          ++itemMutable.count\n          itemMutable.item = item\n          return mapFunction(key, itemMutable.callback, item, index, array)\n        }\n        const currentItemMutable: UseCallbackMapperItemState = {\n          count: maxKeyCount,\n          item,\n          callback: function (this: any, ...args: any[]) {\n            mutable.handler.call(this, currentItemMutable.item, ...args)\n          }\n        }\n        itemsMutable[key] = currentItemMutable\n        return mapFunction(key, currentItemMutable.callback, item, index, array)\n      })\n      const deletedKeys = []\n      for (const key in itemsMutable) {\n        if (itemsMutable[key].count < maxKeyCount) {\n          deletedKeys.push(key)\n        }\n      }\n      deletedKeys.forEach((key) => {\n        delete itemsMutable[key]\n      })\n      return mapped\n    }\n  }\n  ref.current = mutable\n  return mutable.mapper\n}\n\nexport default useFixedCallbackMapper\n","import { useRef } from 'react'\nimport {\n  Handler,\n  KeyGetter,\n  MapFunction,\n  UseBindedCallbackMapperState,\n  UseCallbackMapperItemsState,\n  UseCallbackMapperItemState\n} from './typings'\n\nconst useBindedCallbackMapper = (\n  handler: Handler,\n  keyGetter: string | KeyGetter,\n  ...bindArgs: any[]\n) => {\n  const ref = useRef<UseBindedCallbackMapperState>()\n  const current = ref.current\n  if (current) {\n    current.handler = handler\n    current.bindArgs = bindArgs\n    return current.mapper\n  }\n  const itemsMutable: UseCallbackMapperItemsState = {}\n  const getKey: KeyGetter =\n    typeof keyGetter === 'string' ? (obj: Object) => obj[keyGetter] : keyGetter\n  let maxKeyCount = 0\n  const mutable: UseBindedCallbackMapperState = {\n    handler,\n    bindArgs,\n    mapper: (array: Array<Object>, mapFunction: MapFunction) => {\n      ++maxKeyCount\n      const mapped = array.map((item, index, array) => {\n        const key = getKey(item)\n        const itemMutable = itemsMutable[key]\n        if (itemMutable) {\n          ++itemMutable.count\n          itemMutable.item = item\n          return mapFunction(key, itemMutable.callback, item, index, array)\n        }\n        const currentItemMutable: UseCallbackMapperItemState = {\n          count: maxKeyCount,\n          item,\n          callback: function (this: any, ...args: any[]) {\n            mutable.handler.call(\n              this,\n              currentItemMutable.item,\n              ...mutable.bindArgs,\n              ...args\n            )\n          }\n        }\n        itemsMutable[key] = currentItemMutable\n        return mapFunction(key, currentItemMutable.callback, item, index, array)\n      })\n      const deletedKeys = []\n      for (const key in itemsMutable) {\n        if (itemsMutable[key].count < maxKeyCount) {\n          deletedKeys.push(key)\n        }\n      }\n      deletedKeys.forEach((key) => {\n        delete itemsMutable[key]\n      })\n      return mapped\n    }\n  }\n  ref.current = mutable\n  return mutable.mapper\n}\n\nexport default useBindedCallbackMapper\n","import { useRef } from 'react'\nimport {\n  Handler,\n  KeyGetter,\n  MapFunction,\n  UseCallbackMapperItemsState,\n  UseCallbackMapperItemState,\n  UseDynamicBindedCallbackMapperState\n} from './typings'\n\nconst useDynamicBindedCallbackMapper = (...bindArgs: any[]) => {\n  const ref = useRef<UseDynamicBindedCallbackMapperState>()\n  const current = ref.current\n  if (current) {\n    current.bindArgs = bindArgs\n    return current.mapper\n  }\n  const itemsMutable: UseCallbackMapperItemsState = {}\n  let maxKeyCount = 0\n  const mutable: any = {\n    bindArgs,\n    mapper: (array: Array<Object>, mapFunction: MapFunction) => {\n      ++maxKeyCount\n      const mapped = array.map((item, index, array) => {\n        const key = mutable.getKey(item)\n        const itemMutable = itemsMutable[key]\n        if (itemMutable) {\n          ++itemMutable.count\n          itemMutable.item = item\n          return mapFunction(key, itemMutable.callback, item, index, array)\n        }\n        const currentItemMutable: UseCallbackMapperItemState = {\n          count: maxKeyCount,\n          item,\n          callback: function (this: any, ...args: any[]) {\n            return mutable.handler?.call(\n              this,\n              currentItemMutable.item,\n              ...mutable.bindArgs,\n              ...args\n            )\n          }\n        }\n        itemsMutable[key] = currentItemMutable\n        return mapFunction(key, currentItemMutable.callback, item, index, array)\n      })\n      const deletedKeys = []\n      for (const key in itemsMutable) {\n        if (itemsMutable[key].count < maxKeyCount) {\n          deletedKeys.push(key)\n        }\n      }\n      deletedKeys.forEach((key) => {\n        delete itemsMutable[key]\n      })\n      return mapped\n    }\n  }\n  const mapper = mutable.mapper\n  mapper.setHandler = (handler: Handler) => {\n    mutable.handler = handler\n    delete mapper.setHandler\n  }\n  mapper.setKeyGetter = (keyGetter: string | KeyGetter) => {\n    if (typeof keyGetter === 'string') {\n      mutable.getKey = (obj: any) => obj[keyGetter]\n    } else {\n      mutable.getKey = keyGetter\n    }\n    delete mapper.setKeyGetter\n  }\n  ref.current = mutable\n  return mapper\n}\n\nexport default useDynamicBindedCallbackMapper\n","import './index.css'\n\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}